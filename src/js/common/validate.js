/*

A Fluid Component to handle JSON Schema validation.

Pass JSON content to this component's `validate(schemaKey, JSON)` invoker, and it
will be parsed using [AJV](https://github.com/epoberezkin/ajv).

You are expected to configure one or more schemas which will be read from `options.schemaContents`.  The `schemaKey`
value passed to `validate` is expected to match one of the keys in `options.schemaContent`.

You can change the behavior of AJV by updating `options.validatorOptions` (check their documentation for the syntax).

If there are no validation errors, we return `undefined`.  If there are validation errors, the raw output generated by
AJV is transformed using the static function `sanitizeValidationErrors`.

As an example, let's assume that you have a JSON payload like the following that you wish to validate:

  ```
  {
    field1: "invalid",
    category1: {
      nestedField1: "invalid"
    }
  }
  ```

Assuming that each value was invalid, you might see validation output like the following:

  ```
  {
    fieldErrors: {
      field1: ["field1 must be 8 characters or longer.", "field1 must contain at least one uppercase letter."],
      category1: {
        nestedField1: ["nested field is not a valid number."]
      }
  }
  ```

 */

"use strict";
var fluid = fluid || require("infusion");
var gpii  = fluid.registerNamespace("gpii");

var Ajv = require("ajv");

fluid.registerNamespace("gpii.schema.validator");

gpii.schema.validator.init = function (that) {
    // We persist a single AJV instance so that we can take advantage of its automatic compiling and caching.
    that.ajv = Ajv(that.options.validatorOptions);

    gpii.schema.validator.refreshSchemas(that);
};

gpii.schema.validator.validate = function (that, key, content) {
    // TODO:  Confirm that remote references work in ajv and then delete this block.
    //fluid.each(that.schemaContents, function (schemaContent, schemaKey) {
    //    validator.setRemoteReference(schemaKey, schemaContent);
    //});

    var contentValid = that.ajv.validate(key, content);
    if (!contentValid) {
        return (gpii.schema.validator.sanitizeValidationErrors(that.ajv.errors));
    }

    return undefined;
};


/*
 AJV gives us output like:

 [
     {
         "keyword": "minLength",
         "dataPath": ".password",
         "message": "should NOT be shorter than 8 characters"
     },
     {
         "keyword": "pattern",
         "dataPath": ".password",
         "message": "should match pattern \"[A-Z]+\""
     },
     {
         "keyword": "required",
         "dataPath": ".deep.required",
         "message": "is a required property"
     }
 ]

 We need to break this down so that the messages can be associated with individual model variables and associated form
 elements.  This allows us to show overall in-context feedback to the user.

 */
gpii.schema.validator.sanitizeValidationErrors = function (errors) {
    var sanitizedErrors = { fieldErrors: {}};

    fluid.each(errors, function (error) {
        gpii.schema.validator.sanitizeError(error, sanitizedErrors);
    });

    return sanitizedErrors;
};

gpii.schema.validator.sanitizeError = function (error, errorMap) {
    // Errors are associated with the right field based on the `dataPath` received from AJV.
    var path = gpii.schema.validator.extractPathSegments(error);
    gpii.schema.validator.saveToPath(path, error.message, errorMap);
};


/*

  AJV represents the location of validation failures using path notation like `.category.subcategory.field`.  This function
  converts that notation into a series of path segments that can be passed to `gpii.schema.validator.saveToPath`.

  Path segments with a literal period in their name are encoded like `sky.['middle.earth'].moria`.

  This function handles the general case as well as escaped variables, and converts them to a list of path segments
  like `["sky", "middle.earth", "moria"]`.  These segments are used in other functions to check for the existence of
  variables, etc.

 */
gpii.schema.validator.extractPathSegments = function (error) {
    var segments = [];

    // A regular expression to split the curent segment and the remainder from one another: https://xkcd.com/1171/
    var slicingRegexp = /^(\['[^\']+'\]|[^\[\.]+)\.(.+)$/;

    // Strip the leading dot up front
    var remainingPath = error.dataPath.replace(/^\./, "");

    // Iterate through, splitting by dots while preserving escaped dot notation (see above).
    var matches = remainingPath.match(slicingRegexp);
    while (matches) {
        segments.push(gpii.schema.validator.sanitizePathSegment(matches[1]));
        remainingPath = matches[2];
        matches = remainingPath.match(slicingRegexp);
    }

    // The last segment will not have two parts and can be added in its entirety
    segments.push(gpii.schema.validator.sanitizePathSegment(remainingPath));

    return segments;
};

/*

  Because dots are allowed in Javascript/JSON object keys, any segment with a dot is escaped by AJV.  The simplest
  example is `this.that`, which would be escaped as `['this.that']`.  This gives us three additional special characters,
  namely the square brackets and the single quote.

  If any of those are used, additional escaping is introduced, so `['this.that']` becomes `['[\\'this.that\\']']`.  This
  introduces the final special character, namely the backslash.

  If an escaped backslash is used, it is double escaped, so that `a\\b` becomes `a\\\\b`.

  This function takes care of reversing this process including all combinations, to ensure that we end up with the
  original unescaped literal key.

 */
gpii.schema.validator.sanitizePathSegment = function (segment) {
    var hasSpecialRegexp = /\['(.+)'\]/;

    // If we are surrounded by `['']`, extract the inner content and then unescape it.
    var matches = segment.match(hasSpecialRegexp);
    if (matches) {
        // unescape the remaining variables by using them to create a new `String`.
        return String(matches[1]);
    }

    return segment;
};

// Resolve the underlying data from a hierarchical object using an array of path segments. Returns the portion of the
// original object at the selected path.  As an example:
//
// `resolveOrCreateTargetFromPath({ one: { two: { three: { four: "five"}}}}, ["one", "two", "three"])`
//
// Should return:
//
// `{ four: "five" }`
//
// Note that the relevant portion of the original object is returned, and not just the value.  Note also that if the
// deep structure does not already exist, it will be created.  Thus:
//
// `resolveOrCreateTargetFromPath({}, ["one","two","three"])`
//
// Will return:
//
// `{ one: { two: { three: [] }}}`
//
gpii.schema.validator.resolveOrCreateTargetFromPath = function (target, path) {
    var resolvedTarget = target;
    for (var a = 0; a < path.length; a++) {
        var segment = path[a];
        if (!resolvedTarget[segment]) {
            resolvedTarget[segment] = a === path.length - 1 ? [] : {};
        }

        resolvedTarget = resolvedTarget[segment];
    }
    return resolvedTarget;
};

/*
  A function to save error messages to the right position within our "sanitized" JSON output (see header for example).

  `path`:
    An array of path segments pointing to a variable in `errorMap`.  If you are describing validation errors related to
    the field `category.subcategory.field`, the path would look like `["category", "subcategory", "field"]`.

  `errorString`:
    An error message to be saved to the right `path` within `errorMap`

  `errorMap`:
    A map of error messages for the whole document.  This will be modified with new values.
 */
gpii.schema.validator.saveToPath = function (path, errorString, errorMap) {
    var target = errorMap.fieldErrors;
    target     = gpii.schema.validator.resolveOrCreateTargetFromPath(target, path);
    target.push(errorString);
};

/*

If we receive new schemas, make the validator aware of them so that we can simply validate using their key.

 */
gpii.schema.validator.refreshSchemas = function (that) {
    // Update the list of schemas using the supplied content
    fluid.each(that.model.schemas, function (schemaContent, schemaKey) {
        // AJV will not let us overwrite an existing schema , so we have to remove the current content first.
        if (that.ajv.getSchema(schemaKey)) {
            that.ajv.removeSchema(schemaKey);
        }
        that.ajv.addSchema(schemaContent, schemaKey);
    });
};

fluid.defaults("gpii.schema.validator", {
    gradeNames: ["fluid.modelComponent"],
    validatorOptions: {
        verbose: false,  // Prevent invalid data (such as passwords) from being displayed in error messages
        messages: true,  // Display human-readable error messages
        allErrors: true  // Generate a complete list of errors and not just the first failure.
    },
    model: {
        schemas: {}
    },
    invokers: {
        validate: {
            funcName: "gpii.schema.validator.validate",
            args:     ["{that}", "{arguments}.0", "{arguments}.1"]
        }
    },
    listeners: {
        "onCreate.init": {
            funcName: "gpii.schema.validator.init",
            args:     ["{that}"]
        }
    },
    modelListeners: {
        "schemas": {
            funcName:      "gpii.schema.validator.refreshSchemas",
            excludeSource: "init",
            args:          ["{that}"]
        }
    }
});
